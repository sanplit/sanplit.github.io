---
layout: post
title: "Unix Philosophy"
date: 2012-12-02
comments: false
---

<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><br />Here are some awesome set of rules that a developer should follow. These are tried and tested set of rules from Unix philosophy.<br /><div><br /></div><div><ul style="text-align: left;"> <li>Rule of Modularity: Write simple parts connected by clean interfaces.</li> <li>Rule of Clarity: Clarity is better than cleverness.</li> <li>Rule of Composition: Design programs to be connected to other programs.</li> <li>Rule of Separation: Separate policy from mechanism; separate interfaces from engines.</li> <li>Rule of Simplicity: Design for simplicity; add complexity only where you must.</li> <li>Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do.</li> <li>Rule of Transparency: Design for visibility to make inspection and debugging&nbsp;easier.</li> <li>Rule of Robustness: Robustness is the child of transparency and simplicity.</li> <li>Rule of Representation: Fold knowledge into data so program logic can be stupid and robust.</li> <li>Rule of Least Surprise: In interface design, always do the least surprising thing.</li> <li>Rule of Silence: When a program has nothing surprising to say, it should say nothing.</li> <li>Rule of Repair: When you must fail, fail noisily and as soon as possible.</li> <li>Rule of Economy: Programmer time is expensive; conserve it in preference to machine time.</li> <li>Rule of Generation: Avoid hand-hacking; write programs to write programs when you can.</li> <li>Rule of Optimization: Prototype before polishing. Get it working before you optimize it.</li> <li>Rule of Diversity: Distrust all claims for “one true way”.</li> <li>Rule of Extensibility: Design for the future, because it will be here sooner than you think.</li></ul></div></div></div>
